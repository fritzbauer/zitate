<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Zitate-Datenbank</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/sql-wasm.js"></script>-->
  <script src=".\sql-wasm.js"></script>
  <style>
    :root{
      /* Light palette */
      --bg: #f6f7fb;
      --card: #ffffff;
      --muted: #64748b;         /* slate-500 */
      --text: #1f2937;          /* gray-800 */
      --accent: #2563eb;        /* blue-600 */
      --accent-2:#7c3aed;       /* violet-600 */
      --danger:#e11d48;         /* rose-600 */
      --ok:#16a34a;             /* green-600 */
      --border: rgba(17, 24, 39, 0.12); /* subtle dark border */
      --shadow: 0 8px 24px rgba(17, 24, 39, 0.08), 0 2px 8px rgba(17, 24, 39, 0.06);
      --radius: 12px;
    }

    html, body {
      height: 100%;
      /* soft light vignette */
      background: radial-gradient(1200px 800px at 20% -10%, #ffffff 0%, #f3f5fb 55%, #eef1f8 100%);
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      color: var(--text);
    }

    .app {
      max-width: 1100px; margin: 24px auto; padding: 0 16px 80px;
    }

    /* Topbar */
    .topbar {
      position: sticky; top: 0; z-index: 10;
      backdrop-filter: blur(6px);
      background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.65) 70%, rgba(255,255,255,0));
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner { display:flex; align-items:center; gap:12px; padding:12px 16px; max-width:1100px; margin:0 auto; }
    .brand { font-weight: 700; letter-spacing: .3px; font-size: 18px; margin-right: auto; color: #0f172a; }

    /* Buttons & inputs */
    .btn{
      display:inline-flex; align-items:center; gap:.5rem;
      background: linear-gradient(180deg, #ffffff, #f2f5fb);
      color: var(--text);
      border:1px solid var(--border); border-radius: 10px;
      padding:10px 14px; cursor:pointer; box-shadow: var(--shadow);
      transition:.15s transform ease, .15s filter ease, .15s background ease;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.02); }
    .btn:active{ transform: translateY(0); filter: brightness(.99); }
    .btn.primary{
      background: linear-gradient(180deg, #60a5fa, var(--accent));
      color:#ffffff; font-weight: 700; border-color: transparent;
    }
    .btn.danger{
      background: linear-gradient(180deg, #fb7185, var(--danger));
      color:#ffffff; font-weight: 700; border-color: transparent;
    }
    .btn.ghost{
      background: transparent; border-color: var(--border); color: #0f172a;
    }

    .toolbar { display:flex; flex-wrap: wrap; gap: 10px; align-items:center; }
    .toolbar .spacer { flex: 1; }

    .card {
      background: linear-gradient(180deg, var(--card), #fafbff);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .section-title { margin: 18px 0 8px; font-size: 18px; font-weight: 700; color: #334155; }

    .grid { display:grid; gap:12px; }
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .grid.cols-1 { grid-template-columns: 1fr; }
    @media (max-width: 800px){ .grid.cols-2 { grid-template-columns: 1fr; } }

    label { font-size: 12px; color: var(--muted); display:block; margin-bottom:6px; letter-spacing:.2px; }

    input[type="text"], textarea, select {
      width: 100%; box-sizing: border-box; color: var(--text);
      background: #ffffff; border:1px solid var(--border); border-radius: 10px;
      padding: 10px 12px; outline: none; transition: .15s border ease, .15s box-shadow ease;
      box-shadow: inset 0 0 0 1px transparent, 0 6px 14px rgba(17,24,39,0.06);
    }
    input::placeholder, textarea::placeholder { color: #94a3b8; }
    input:focus, textarea:focus, select:focus {
      border-color: #93c5fd; /* light-blue-300 */
      box-shadow: 0 0 0 4px rgba(37, 99, 235, .18);
    }
    textarea { resize: vertical; }

    /* Table */
    table { width: 100%; border-collapse: collapse; }
    thead th {
      text-align:left; font-size: 12px; color: var(--muted); font-weight: 700;
      border-bottom: 1px solid var(--border); padding: 10px; position: sticky; top: 0;
      background: #f8fafc; /* light header */
      backdrop-filter: blur(2px);
    }
    tbody td { border-bottom: 1px solid var(--border); padding: 10px; vertical-align: top; }
    tbody tr:hover { background: rgba(15, 23, 42, 0.035); } /* subtle slate tint */
    .col-actions { width: 1%; white-space: nowrap; }
    .truncate { display:-webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; overflow: hidden; }

    .muted { color: var(--muted); font-size: 12px; }

    .pagination { display:flex; align-items:center; gap:10px; }
    .pill { padding:6px 10px; border:1px solid var(--border); border-radius: 999px; background:#fff; }

    .counter { font-size: 12px; color: var(--muted); }

    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">üóÇÔ∏è Zitate‚ÄëDatenbank</div>
      <button class="btn" id="openBtn">üìÇ&nbsp;Datenbank √∂ffnen</button>
      <button class="btn" id="saveBtn">üíæ&nbsp;Speichern</button>
      <button id="dropTableBtn" class="btn">Drop Table</button>
    </div>
  </div>

  <div class="app">
    <!-- Suche -->
    <div class="card" style="margin-top:12px;">
      <div class="toolbar">
        <div style="flex:1; min-width:220px;">
          <label for="searchInput">üîç Zitate suchen</label>
          <input type="text" id="searchInput" placeholder="Suchbegriff in Titel, Quelle, Zitat oder Genutzt ‚Ä¶" />
          <div class="hint">Ergebnisse sind paginiert. Markierungen bleiben beim Bl√§ttern erhalten.</div>
        </div>
        <div>
          <label for="pageSize">Treffer pro Seite</label>
          <select id="pageSize">
            <option value="10">10</option>
            <option value="20" selected>20</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </div>
        <div class="spacer"></div>
        <div class="counter"><span id="totalCount">0</span> Treffer ‚Ä¢ Markiert: <span id="selectedCount">0</span></div>
        <button class="btn" id="selectPageBtn">Seite markieren</button>
        <button class="btn ghost" id="clearPageBtn">Seitenmarkierung aufheben</button>
        <button class="btn primary" id="exportRtfBtn">‚éò&nbsp;Markierte als RTF kopieren</button>
        <!--<button class="btn danger" id="deleteSelectedBtn">üóëÔ∏è&nbsp;Markierte l√∂schen</button>-->
      </div>
    </div>

    <!-- Ergebnisse -->
    <div class="card" style="margin-top:12px;">
      <div style="overflow:auto; max-height: 55vh;">
        <table id="resultsTable">
          <thead>
            <tr>
              <th style="width:42px;"><input type="checkbox" id="selectAllCheckbox" /></th>
              <th>Titel</th>
              <th>Quelle</th>
              <th>Zitat</th>
              <th>Genutzt</th>
              <th class="col-actions">Aktionen</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:10px;">
        <div class="pagination">
          <button class="btn ghost" id="prevPageBtn">‚óÄ</button>
          <span class="pill">Seite <span id="currentPage">1</span> / <span id="totalPages">1</span></span>
          <button class="btn ghost" id="nextPageBtn">‚ñ∂</button>
        </div>
        <div class="muted" id="pageInfo"></div>
      </div>
    </div>

    <!-- Neues Zitat -->
    <div class="card" style="margin-top:12px;">
      <div class="section-title">‚ûï Neues Zitat hinzuf√ºgen</div>
      <div class="grid cols-2">
        <div>
          <label for="quoteTitle">Titel</label>
          <input type="text" id="quoteTitle" placeholder="Kurztitel oder Schlagwort" />
        </div>
        <div>
          <label for="quoteSource">Quelle</label>
          <input type="text" id="quoteSource" placeholder="Autor, Werk, URL, ‚Ä¶" />
        </div>
      </div>
      <div class="grid cols-1" style="margin-top:8px;">
        <div>
          <label for="quoteText">Zitat (20 Zeilen)</label>
          <textarea id="quoteText" rows="20" placeholder="‚ÄûWortlaut des Zitats ‚Ä¶‚Äú"></textarea>
        </div>
        <div>
          <label for="quoteUsed">Genutzt (20 Zeilen)</label>
          <textarea id="quoteUsed" rows="20" placeholder="Kontext, wo/wie verwendet, Notizen ‚Ä¶"></textarea>
        </div>
      </div>
      <div style="margin-top:12px;">
        <button class="btn primary" id="addQuoteBtn">Zitat speichern</button>
      </div>
    </div>
  </div>

<script>
    let db;
    let fileHandle;
    let currentPage = 1;
    let pageSize = 20;
    let totalResults = 0;
    let selectedIds = new Set();
    let lastSearchTerm = "";

    // Small helpers
    const $ = sel => document.querySelector(sel);

    function debounce(fn, delay = 250) {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
    }

    function escapeHTML(str) {
      return String(str ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    // ---- RTF helpers ----
    // Convert JS string to RTF-safe string with unicode support
    function rtfEscapeUnicode(str) {
      const specials = /[\\{}]/g;
      const escapeSpecials = s => s.replace(specials, m => '\\' + m);

      // iterate code points safely
      let out = '';
      for (const ch of Array.from(str ?? '')) {
        const cp = ch.codePointAt(0);
        // ASCII range and not special: output as-is
        if (cp <= 0x7f && !/^[\\{}]$/.test(ch)) { out += ch; continue; }
        // newline -> RTF line break
        if (ch === '\n') { out += '\\line '; continue; }
        // tab
        if (ch === '\t') { out += '\\tab '; continue; }
        // For non-BMP, encode surrogate pair as two \u values
        if (cp > 0xFFFF) {
          const u = cp - 0x10000;
          const high = 0xD800 + (u >> 10);
          const low  = 0xDC00 + (u & 0x3FF);
          const sHigh = (high <= 32767 ? high : high - 65536);
          const sLow  = (low  <= 32767 ? low  : low  - 65536);
          out += `\\u${sHigh}?\\u${sLow}?`;
        } else {
          // escape specials as well
          const esc = escapeSpecials(ch);
          if (esc !== ch) { out += esc; continue; }
          const signed = (cp <= 32767 ? cp : cp - 65536);
          out += `\\u${signed}?`;
        }
      }
      return out;
    }

    function buildRtf(quotes) {
      // Simple, readable RTF: Title bold, Source italic (muted), then Quote text and Used notes as paragraphs.
      const header = '{\\rtf1\\ansi\\deff0\\fs22\\f0 ';
      const body = quotes.map(q => {
        const title = rtfEscapeUnicode(q.titel || '');
        const quelle = rtfEscapeUnicode(q.quelle || '');
        const zitat = rtfEscapeUnicode(q.zitat || '');
        const genutzt = rtfEscapeUnicode(q.genutzt || '');
        const parts = [];
        if (title) parts.push(`\\b ${title}\\b0\\par`);
        if (quelle) parts.push(`\\i ${quelle}\\i0\\par`);
        if (zitat) parts.push(`${zitat}\\par`);
        if (genutzt) parts.push(`\\cf2 ${genutzt}\\cf0\\par`);
        // separator:
        parts.push('\\par');
        return parts.join('\n');
      }).join('\n');
      const footer = '}';
      return header + body + footer;
    }

    async function copyRtfToClipboard(rtfString, plainTextFallback) {
      if (navigator.clipboard && window.ClipboardItem) {
        try {
          const blob = new Blob([rtfString], { type: 'text/rtf' });
          const item = new ClipboardItem({ 'text/rtf': blob, 'text/plain': new Blob([plainTextFallback], { type: 'text/plain' }) });
          await navigator.clipboard.write([item]);
          alert('Markierte Zitate wurden als RTF in die Zwischenablage kopiert.');
          return;
        } catch (err) {
          console.error('RTF failed:', err);
        }
      }
      // Fallback to plain text
      try {
        await navigator.clipboard.writeText(plainTextFallback);
        alert('RTF wird nicht unterst√ºtzt. Plain-Text wurde in die Zwischenablage kopiert.');
      } catch (err) {
        alert('Kopieren in die Zwischenablage nicht m√∂glich (Berechtigungen?).\nFehler: ' + err);
        console.error('Clipboard write failed:', err);
      }
    }

    // ---- DB init ----
    async function loadDatabase() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{ description: 'SQLite DB', accept: { 'application/octet-stream': ['.sqlite'] } }]
        });
        fileHandle = handle;
        const file = await fileHandle.getFile();
        const buffer = await file.arrayBuffer();
        const SQL = await initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}` });
        db = new SQL.Database(new Uint8Array(buffer));

        // Create table if not exists with the new schema
        db.run(`CREATE TABLE IF NOT EXISTS quotes (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          titel   TEXT,
          quelle  TEXT,
          zitat   TEXT,
          genutzt TEXT,
          text    TEXT,
          source  TEXT,
          tag     TEXT,
          DeletedDateTime TEXT
        )`);

        // Load last pageSize from localStorage
        const savedSize = localStorage.getItem('quotes_pageSize');
        if (savedSize) { pageSize = parseInt(savedSize, 10) || 20; $('#pageSize').value = String(pageSize); }

        // Do initial search
        await searchQuotes(true);
      } catch (e) {
        console.error(e);
        alert("√ñffnen fehlgeschlagen oder abgebrochen.");
      }
    }

    async function saveDatabase() {
      if (!db || !fileHandle) { alert("Keine Datenbank ge√∂ffnet."); return; }
      const writable = await fileHandle.createWritable();
      const buffer = db.export();
      await writable.write(buffer);
      await writable.close();
      //alert("Datenbank gespeichert.");
    }

    // ---- NEW: Function to drop the table ----
    async function dropTable() {
        if (!db) { alert("Bitte zuerst eine Datenbank √∂ffnen."); return; }
        if (!confirm("WARNUNG: Sind Sie sicher, dass Sie alle Zitate permanent l√∂schen wollen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden.")) {
            return;
        }
        try {
            db.run('DROP TABLE IF EXISTS quotes');
            alert("Die Tabelle 'quotes' wurde gel√∂scht.");
            // Refresh the view, which will now be empty
            await searchQuotes(true);
            // Save the change to the file
            await saveDatabase();
        } catch (e) {
            console.error(e);
            alert("Fehler beim L√∂schen der Tabelle: " + e.message);
        }
    }

    // ---- CRUD ----
    function addQuote() {
      if (!db) { alert("Bitte zuerst eine Datenbank √∂ffnen."); return; }
      const titel   = $('#quoteTitle').value.trim();
      const quelle  = $('#quoteSource').value.trim();
      const zitat   = $('#quoteText').value.trim();
      const genutzt = $('#quoteUsed').value.trim();

      if (!titel || !quelle || !zitat) {
        alert("Titel, Quelle und Zitat sind erforderlich.");
        return;
      }

      db.run(
        `INSERT INTO quotes (titel, quelle, zitat, genutzt, text, source, tag)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [titel, quelle, zitat, genutzt, zitat, quelle, null]
      );

      // Reset form
      $('#quoteTitle').value = '';
      $('#quoteSource').value = '';
      $('#quoteText').value = '';
      $('#quoteUsed').value = '';

      // Refresh and persist
      currentPage = 1;
      searchQuotes(true);
      saveDatabase().catch(()=>{});
    }

    // MODIFIED: deleteQuote now performs a soft delete
    function deleteQuote(id) {
      if (!db) return;
      if (!confirm("Dieses Zitat wirklich l√∂schen?")) return;
      const timestamp = new Date().toISOString();
      db.run(`UPDATE quotes SET DeletedDateTime = ? WHERE id = ?`, [timestamp, id]);
      selectedIds.delete(id);
      searchQuotes();
      saveDatabase().catch(()=>{});
    }

    // MODIFIED: deleteSelected now performs a soft delete
    function deleteSelected() {
      if (!db) return;
      if (selectedIds.size === 0) { alert("Keine markierten Zitate."); return; }
      if (!confirm(`Wirklich ${selectedIds.size} markierte Zitat(e) l√∂schen?`)) return;

      const ids = Array.from(selectedIds);
      const placeholders = ids.map(() => '?').join(',');
      const timestamp = new Date().toISOString();

      try {
        db.run(`UPDATE quotes SET DeletedDateTime = ? WHERE id IN (${placeholders})`, [timestamp, ...ids]);
      } catch (e) {
        alert("L√∂schen fehlgeschlagen: " + e.message);
        return;
      }

      selectedIds.clear();
      searchQuotes();
      saveDatabase().catch(()=>{});
    }

    // ---- Search & Pagination ----
    /**
     * Erweitertes WHERE f√ºr SQLite-Suche mit boolescher Syntax.
     * Unterst√ºtzt: AND, OR, NOT, Klammern, implizites AND, optionale Phrasen in "..."
     */
    function buildSearchWhere(term) {
      // Basis: gel√∂schte Eintr√§ge immer ausschlie√üen
      const baseWhere = "WHERE DeletedDateTime IS NULL";
      const columns = ["titel", "quelle", "zitat", "genutzt", "text", "source"];

      if (!term || !term.trim()) {
        return { where: baseWhere, params: [] };
      }

      // Kompiliere die boolesche Suche in SQL
      const { sql, params } = compileBooleanSearch(term, columns);

      const where = `${baseWhere} AND (${sql})`;
      return { where, params };
    }

    /**
     * √úbersetzt eine Bool-Query (AND/OR/NOT, Klammern, Phrasen) in SQL + Parameter.
     * @param {string} query - z.B. `(√Ñpfel OR Birnen OR Auto) AND Testsieger AND NOT (Ferrari OR Porsche)`
     * @param {string[]} columns - Spalten, die mit LIKE durchsucht werden sollen
     * @returns {{ sql: string, params: any[] }}
     */
    function compileBooleanSearch(query, columns) {
      const tokens = insertImplicitAnd(tokenizeBooleanQuery(query));
      const rpn = toRPN(tokens);
      const { sql, params } = rpnToSql(rpn, columns);
      return { sql, params };
    }

    /* ============================
      Tokenizer
      ============================ */

    /**
     * Zerlegt die Query in Tokens: TERM, AND, OR, NOT, LPAREN, RPAREN.
     * Unterst√ºtzt Phrasen in "..." oder '...'.
     */
    function tokenizeBooleanQuery(input) {
      const tokens = [];
      let i = 0;

      const isSpace = (c) => /\s/.test(c);

      while (i < input.length) {
        const ch = input[i];

        if (isSpace(ch)) {
          i++;
          continue;
        }

        if (ch === "(") {
          tokens.push({ type: "LPAREN" });
          i++;
          continue;
        }
        if (ch === ")") {
          tokens.push({ type: "RPAREN" });
          i++;
          continue;
        }

        // Phrasen in Anf√ºhrungszeichen
        if (ch === `"` || ch === `'`) {
          const quote = ch;
          i++;
          let value = "";
          while (i < input.length) {
            const c = input[i];
            if (c === "\\") {
              // Escape: √ºbernehme n√§chstes Zeichen w√∂rtlich
              if (i + 1 < input.length) {
                value += input[i + 1];
                i += 2;
                continue;
              }
            }
            if (c === quote) {
              i++; // schlie√üendes Quote konsumieren
              break;
            }
            value += c;
            i++;
          }
          if (value.length > 0) {
            tokens.push({ type: "TERM", value });
          }
          continue;
        }

        // Normale W√∂rter (bis Space oder Klammer)
        let start = i;
        while (i < input.length && !/\s|\(|\)/.test(input[i])) {
          i++;
        }
        const word = input.slice(start, i);
        const upper = word.toUpperCase();

        if (upper === "AND" || upper === "OR" || upper === "NOT") {
          tokens.push({ type: upper });
        } else {
          tokens.push({ type: "TERM", value: word });
        }
      }

      return tokens;
    }

    /**
     * F√ºgt implizite ANDs zwischen benachbarten Ausdr√ºcken ein:
     * TERM ( oder ) TERM oder ) ( oder TERM NOT oder ) NOT -> zwischen diese Paare kommt AND
     */
    function insertImplicitAnd(tokens) {
      const out = [];
      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        if (i > 0) {
          const p = tokens[i - 1];
          const isLeft = p.type === "TERM" || p.type === "RPAREN";
          const isRight = t.type === "TERM" || t.type === "LPAREN" || t.type === "NOT";
          if (isLeft && isRight) {
            out.push({ type: "AND" });
          }
        }
        out.push(t);
      }
      return out;
    }

    /* ============================
      Shunting-Yard -> RPN
      ============================ */

    function toRPN(tokens) {
      const output = [];
      const ops = [];

      const precedence = { OR: 1, AND: 2, NOT: 3 };
      // NOT ist un√§r (rechtsassoziativ), AND/OR bin√§r (linksassoziativ)
      const isOp = (t) => t && (t.type === "OR" || t.type === "AND" || t.type === "NOT");

      for (const tok of tokens) {
        if (tok.type === "TERM") {
          output.push(tok);
          continue;
        }

        if (tok.type === "AND" || tok.type === "OR" || tok.type === "NOT") {
          while (ops.length) {
            const top = ops[ops.length - 1];
            if (
              isOp(top) &&
              (
                precedence[top.type] > precedence[tok.type] ||
                (precedence[top.type] === precedence[tok.type] && tok.type !== "NOT") // NOT rechtsassoziativ
              )
            ) {
              output.push(ops.pop());
            } else {
              break;
            }
          }
          ops.push(tok);
          continue;
        }

        if (tok.type === "LPAREN") {
          ops.push(tok);
          continue;
        }

        if (tok.type === "RPAREN") {
          while (ops.length && ops[ops.length - 1].type !== "LPAREN") {
            output.push(ops.pop());
          }
          if (!ops.length) {
            throw new Error("Unbalancierte Klammern in der Suchanfrage.");
          }
          ops.pop(); // LPAREN entfernen
          continue;
        }
      }

      while (ops.length) {
        const op = ops.pop();
        if (op.type === "LPAREN" || op.type === "RPAREN") {
          throw new Error("Unbalancierte Klammern in der Suchanfrage.");
        }
        output.push(op);
      }

      return output;
    }

    /* ============================
      RPN -> SQL
      ============================ */

   function rpnToSql(rpn, columns, options = {}) {
      const fallbackSql = options.fallbackSql || "1=1"; // Tautologie bei leerem/ung√ºltigem Ausdruck
      const stack = [];

      const safePop = () => (stack.length ? stack.pop() : undefined);

      for (const tok of rpn) {
        if (tok.type === "TERM") {
          stack.push(makeTermClause(tok.value, columns));
          continue;
        }

        if (tok.type === "NOT") {
          const a = safePop();
          if (!a) {
            // unvollst√§ndiger NOT ‚Äì ignorieren
            continue;
          }
          stack.push({
            sql: `NOT (${a.sql})`,
            params: a.params
          });
          continue;
        }

        if (tok.type === "AND" || tok.type === "OR") {
          const b = safePop();
          const a = safePop();

          if (a && b) {
            stack.push({
              sql: `(${a.sql}) ${tok.type} (${b.sql})`,
              params: a.params.concat(b.params)
            });
          } else if (a || b) {
            // Nur ein Operand vorhanden ‚Äì Operator ignorieren, Operand zur√ºck auf den Stack
            stack.push(a || b);
          } else {
            // Gar kein Operand ‚Äì nichts tun
          }
          continue;
        }

        // Unbekannte Token-Typen stillschweigend ignorieren
      }

      if (stack.length === 0) {
        return { sql: fallbackSql, params: [] };
      }

      // Falls mehrere Fragmente √ºbrig sind, konservativ mit AND zusammenfalten
      let acc = stack[0];
      for (let i = 1; i < stack.length; i++) {
        const cur = stack[i];
        acc = {
          sql: `(${acc.sql}) AND (${cur.sql})`,
          params: acc.params.concat(cur.params)
        };
      }

      return acc;
    }


    /* ============================
      Hilfen: LIKE
      ============================ */

    /**
     * Escaped %, _ und \ f√ºr LIKE (wir nutzen ESCAPE '\').
     * Hinweis: Wenn du Nutzern Wildcards erlauben willst (z.B. * => %), 
     * dann ersetze * erst durch % und rufe DANACH diese Funktion NICHT mehr auf
     * oder setze allowWildcards=true und passe die Logik an.
     */
    function escapeLikePattern(s) {
      return s.replace(/([%_\\])/g, "\\$1");
    }

    /**
     * Erzeugt die OR-Verkn√ºpfung √ºber alle Spalten f√ºr einen Suchterm.
     * Verwendet `ESCAPE '\'` damit unser Escaping greift.
     */
    function makeTermClause(rawTerm, columns) {
      const term = String(rawTerm || "").trim();
      // OPTIONAL: Wildcards erlauben
      // const userWild = term.replace(/\*/g, "%").replace(/\?/g, "_");
      // const pattern = `%${userWild}%`;

      // Standard: Wildcards im Input neutralisieren (literal suchen)
      const pattern = `%${escapeLikePattern(term)}%`;

      const cond = "(" + columns.map(c => `COALESCE(${c}, '') LIKE ? ESCAPE '\\'`).join(" OR ") + ")";
      const params = columns.map(() => pattern);
      return { sql: cond, params };
    }

    /* ============================
      Beispiel
      ============================ */

    // const q = `(√Ñpfel OR Birnen OR Auto) AND Testsieger AND NOT (Ferrari OR Porsche)`;
    // const res = buildSearchWhere(q);
    // console.log(res.where);


    function searchQuotes(resetPage = false) {
      if (!db) return;
      const term = $('#searchInput').value.trim();
      if (resetPage || term !== lastSearchTerm) {
        currentPage = 1;
      }
      lastSearchTerm = term;

      const { where, params } = buildSearchWhere(term);

      // Count total matching (non-deleted) results
      let count = 0;
      {
        const stmtCount = db.prepare(`SELECT COUNT(*) as c FROM quotes ${where}`);
        stmtCount.bind(params);
        if (stmtCount.step()) {
          count = stmtCount.getAsObject().c | 0;
        }
        stmtCount.free();
      }
      totalResults = count;

      // Fetch current page
      const offset = (currentPage - 1) * pageSize;
      const stmt = db.prepare(
        `SELECT id, COALESCE(titel,'') as titel, COALESCE(quelle,'') as quelle,
               COALESCE(zitat,'') as zitat, COALESCE(genutzt,'') as genutzt
          FROM quotes
          ${where}
         ORDER BY id DESC
         LIMIT ? OFFSET ?`
      );
      stmt.bind([...params, pageSize, offset]);

      const rows = [];
      while (stmt.step()) {
        rows.push(stmt.getAsObject());
      }
      stmt.free();

      renderResults(rows);
      updatePagination();
    }
    
    // NOTE: Two renderResults functions were present in the original code.
    // I have kept only the more complete, second one.
    function renderResults(rows) {
      const tbody = $('#resultsTable tbody');
      tbody.innerHTML = '';
      const frag = document.createDocumentFragment();

      for (const row of rows) {
        const tr = document.createElement('tr');
        tr.dataset.id = String(row.id);

        // Select checkbox
        const tdSel = document.createElement('td');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selectedIds.has(row.id);
        cb.addEventListener('change', () => {
          if (cb.checked) selectedIds.add(row.id);
          else selectedIds.delete(row.id);
          updateSelectedCounter();
          // update header master
          const allChecked = Array.from(tbody.querySelectorAll('input[type="checkbox"]')).every(x => x.checked);
          $('#selectAllCheckbox').checked = allChecked;
        });
        tdSel.appendChild(cb);
        tr.appendChild(tdSel);

        const tdTitle = document.createElement('td');
        tdTitle.innerHTML = `<div style="font-weight:700">${escapeHTML(row.titel)}</div>`;
        tr.appendChild(tdTitle);

        const tdQuelle = document.createElement('td');
        tdQuelle.textContent = row.quelle;
        tr.appendChild(tdQuelle);

        const tdZitat = document.createElement('td');
        tdZitat.innerHTML = `<div class="truncate">${escapeHTML(row.zitat)}</div>`;
        tr.appendChild(tdZitat);

        const tdGenutzt = document.createElement('td');
        tdGenutzt.innerHTML = `<div class="truncate muted">${escapeHTML(row.genutzt)}</div>`;
        tr.appendChild(tdGenutzt);

        const tdActions = document.createElement('td');
        tdActions.className = 'col-actions';
        const delBtn = document.createElement('button');
        delBtn.className = 'btn';
        delBtn.textContent = 'üóëÔ∏è';
        delBtn.addEventListener('click', () => deleteQuote(row.id));
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        frag.appendChild(tr);
      }

      tbody.appendChild(frag);

      // Header select-all checkbox state
      const rowsIds = rows.map(r => r.id);
      const allSelected = rowsIds.length > 0 && rowsIds.every(id => selectedIds.has(id));
      $('#selectAllCheckbox').checked = allSelected;

      // Update counters
      $('#totalCount').textContent = String(totalResults);
      updateSelectedCounter();

      // Helper buttons bound to current page rows
      $('#selectPageBtn').onclick = () => {
        for (const id of rowsIds) selectedIds.add(id);
        tbody.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        updateSelectedCounter();
        $('#selectAllCheckbox').checked = true;
      };
      $('#clearPageBtn').onclick = () => {
        for (const id of rowsIds) selectedIds.delete(id);
        tbody.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        updateSelectedCounter();
        $('#selectAllCheckbox').checked = false;
      };
    }

    function updatePagination() {
      const totalPages = Math.max(1, Math.ceil(totalResults / pageSize));
      if (currentPage > totalPages) currentPage = totalPages;

      $('#currentPage').textContent = String(currentPage);
      $('#totalPages').textContent = String(totalPages);

      $('#prevPageBtn').disabled = currentPage <= 1;
      $('#nextPageBtn').disabled = currentPage >= totalPages;

      const start = totalResults === 0 ? 0 : (currentPage - 1) * pageSize + 1;
      const end = Math.min(currentPage * pageSize, totalResults);
      $('#pageInfo').textContent = `${start}‚Äì${end} von ${totalResults}`;
    }

    function updateSelectedCounter() {
      $('#selectedCount').textContent = String(selectedIds.size);
    }

    // Export selected as RTF
    function exportSelectedAsRtf() {
      if (!db) { alert("Bitte zuerst eine Datenbank √∂ffnen."); return; }
      if (selectedIds.size === 0) { alert("Keine markierten Zitate."); return; }

      const ids = Array.from(selectedIds);
      // Load full rows for all selected ids
      const placeholders = ids.map(() => '?').join(',');
      const rows = [];
      const stmt = db.prepare(
        `SELECT id, COALESCE(titel,'') as titel, COALESCE(quelle,'') as quelle,
               COALESCE(zitat,'') as zitat, COALESCE(genutzt,'') as genutzt
          FROM quotes
         WHERE id IN (${placeholders}) AND DeletedDateTime IS NULL
         ORDER BY id ASC` // Added DeletedDateTime check for safety
      );
      stmt.bind(ids);
      while (stmt.step()) rows.push(stmt.getAsObject());
      stmt.free();

      const rtf = buildRtf(rows);
      // Plain text fallback with simple formatting
      const textFallback = rows.map(q => {
        const parts = [];
        if (q.titel) parts.push(`*${q.titel}*`);
        if (q.quelle) parts.push(`_${q.quelle}_`);
        if (q.zitat) parts.push(q.zitat);
        if (q.genutzt) parts.push(`(Genutzt: ${q.genutzt})`);
        return parts.join('\n') + '\n';
      }).join('\n');

      copyRtfToClipboard(rtf, textFallback);
    }

    // ---- Event bindings ----
    window.addEventListener('DOMContentLoaded', () => {
      $('#openBtn').addEventListener('click', loadDatabase);
      $('#saveBtn').addEventListener('click', saveDatabase);
      $('#dropTableBtn').addEventListener('click', dropTable); // NEW event listener
      $('#addQuoteBtn').addEventListener('click', addQuote);
      //$('#deleteSelectedBtn').addEventListener('click', deleteSelected);
      $('#exportRtfBtn').addEventListener('click', exportSelectedAsRtf);
      $('#prevPageBtn').addEventListener('click', () => { if (currentPage > 1) { currentPage--; searchQuotes(); } });
      $('#nextPageBtn').addEventListener('click', () => {
        const totalPages = Math.max(1, Math.ceil(totalResults / pageSize));
        if (currentPage < totalPages) { currentPage++; searchQuotes(); }
      });
      $('#pageSize').addEventListener('change', () => {
        pageSize = parseInt($('#pageSize').value, 10) || 20;
        localStorage.setItem('quotes_pageSize', String(pageSize));
        currentPage = 1; searchQuotes();
      });
      $('#searchInput').addEventListener('input', debounce(() => searchQuotes(true), 250));
      $('#selectAllCheckbox').addEventListener('change', () => {
        const tbody = $('#resultsTable tbody');
        const boxes = tbody.querySelectorAll('input[type="checkbox"]');
        const check = $('#selectAllCheckbox').checked;
        boxes.forEach(box => {
          box.checked = check;
          const tr = box.closest('tr');
          const id = Number(tr.dataset.id);
          if (check) selectedIds.add(id); else selectedIds.delete(id);
        });
        updateSelectedCounter();
      });
    });
</script>
</body>
